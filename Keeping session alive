
import org.apache.spark.sql.SparkSession

def getPartitionColumns(spark: SparkSession, tableName: String): Seq[String] = {
  // Execute 'SHOW CREATE TABLE' command to get the table's DDL
  val createTableDDL = spark.sql(s"SHOW CREATE TABLE $tableName").collect().map(_.getString(0)).mkString("\n")

  // Extract the partition column details from the DDL
  val partitionPattern = "(?i)PARTITIONED BY\\s*\\(([^)]+)\\)".r
  partitionPattern.findFirstMatchIn(createTableDDL) match {
    case Some(matched) => 
      val partitionPart = matched.group(1)
      partitionPart.split(",").map(_.trim.split("\\s+")(0)) // Extracting column names
    case None => 
      Array[String]() // Return an empty array if the table is not partitioned
  }
}

// Usage
val spark: SparkSession = // your SparkSession
val tableName = "your_table_name"
val partitionColumns = getPartitionColumns(spark, tableName)
partitionColumns.foreach(println)


===================================================

import org.apache.spark.sql.DataFrame
import org.apache.spark.sql.functions.col
import scala.util.matching.Regex
import java.time.{LocalDate, Instant, ZoneId}
import java.time.format.DateTimeFormatter

def isString(value: String): Boolean = {
    val stringPattern: Regex = "^[A-Za-z]+$".r
    stringPattern.findFirstIn(value).isDefined
}

def isLikelyDate(value: String): Boolean = {
    // Get the current date
    val currentDate = LocalDate.now()
    val currentYear = currentDate.getYear.toString
    val currentYearMonth = currentDate.format(DateTimeFormatter.ofPattern("yyyyMM"))
    val currentDateStr = currentDate.format(DateTimeFormatter.ofPattern("yyyyMMdd"))

    // Check for Unix timestamp pattern
    val isUnixTimestamp = value.matches("\\d{10}")

    val dateValue = if (isUnixTimestamp) {
        // Convert Unix timestamp to LocalDate
        val instant = Instant.ofEpochSecond(value.toLong)
        val localDate = instant.atZone(ZoneId.systemDefault()).toLocalDate
        localDate.format(DateTimeFormatter.ofPattern("yyyyMMdd"))
    } else {
        value
    }

    // Define regex patterns for various date formats and the current date string
    val datePatterns = Map(
      "\\d{8}" -> currentDateStr, // yyyymmdd
      "\\d{6}" -> currentYearMonth, // yyyymm
      "\\d{4}" -> currentYear // yyyy
    )

    // Check if the value matches any of the date patterns and corresponds to the current date
    datePatterns.exists { case (pattern, dateString) =>
        dateValue.matches(pattern) && dateValue == dateString
    }
}

def validatePartitionColumns(df: DataFrame, partitionColumns: Array[String]): Array[String] = {
    partitionColumns.filter { colName =>
        // Cast the column to string and get the first value, filtering out non-digit characters
        val sampleValue = df.select(col(colName).cast("string")).first().getString(0).filter(_.isDigit)

        // Determine if the value is likely a date or a string
        !isLikelyDate(sampleValue) && !isString(sampleValue)
    }
}

// Usage example
val df1: DataFrame = // Your DataFrame
val partitionColumns = Array("example_date_column", "example_string_column") // Replace with actual column names
val validatedColumns = validatePartitionColumns(df1, partitionColumns)

// Print validated columns
validatedColumns.foreach(println)


===========



import java.time.LocalDate
import java.time.format.{DateTimeFormatter, DateTimeParseException}

def isValidDate(value: String, format: String): Boolean = {
    try {
        LocalDate.parse(value, DateTimeFormatter.ofPattern(format))
        true
    } catch {
        case _: DateTimeParseException => false
    }
}

def isCurrentYearOrMonth(value: String, format: String): Boolean = {
    val currentDate = LocalDate.now()
    val formattedDate = currentDate.format(DateTimeFormatter.ofPattern(format))
    value == formattedDate
}

def isLikelyDate(value: String): Boolean = {
    // Extend this list to include more date formats
    val dateFormats = List(
        "yyyyMMdd",     // Example: 20231219
        "yyyy-MM-dd",   // Example: 2023-12-19
        "yyyy/MM/dd",   // Example: 2023/12/19
        // Add new formats here
        "dd-MM-yyyy",   // Example: 19-12-2023
        "dd/MM/yyyy",   // Example: 19/12/2023
        "MM-dd-yyyy",   // Example: 12-19-2023
        "MM/dd/yyyy",   // Example: 12/19/2023
        "yyyy",         // Example: 2023
        "yyyyMM",       // Example: 202312
        "yyyy-MM",      // Example: 2023-12
        "yyyy/MM"       // Example: 2023/12
    )
    
    // Check if the value matches any of the date formats and corresponds to the current date
    dateFormats.exists(format => {
        if (format.length <= 6) // Formats without day (yyyy or yyyymm)
            isCurrentYearOrMonth(value.filter(_.isDigit), format)
        else
            isValidDate(value, format) && LocalDate.parse(value, DateTimeFormatter.ofPattern(format)).isEqual(LocalDate.now())
    })
}

// Example usage
println(isLikelyDate("2023"))       // True if the current year is 2023
println(isLikelyDate("202312"))     // True if the current year-month is December 2023
println(isLikelyDate("2023-12"))    // True if the current year-month is December 2023
println(isLikelyDate("2023/12"))    // True if the current year-month is December 2023
