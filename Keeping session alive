import java.time.format.{DateTimeFormatter, DateTimeParseException}
import java.time.{LocalDate, Year, YearMonth}

def isValidDate(value: String, format: String): Boolean = {
  try {
    format match {
      case "yyyy" =>
        val year = Year.parse(value, DateTimeFormatter.ofPattern(format))
        year.getValue >= 1900 && year.getValue <= 2099 // Check the range of the year
      case "yyyyMM" =>
        val yearMonth = YearMonth.parse(value, DateTimeFormatter.ofPattern(format))
        yearMonth.getYear >= 1900 && yearMonth.getYear <= 2099 // Check the range of the year
      case "MMyyyy" =>
        // Assuming the format for MMyyyy is provided correctly, e.g., "122024" for December 2024
        val yearMonth = YearMonth.parse(value, DateTimeFormatter.ofPattern(format))
        yearMonth.getYear >= 1900 && yearMonth.getYear <= 2099 // Check the range of the year
      case _ =>
        LocalDate.parse(value, DateTimeFormatter.ofPattern(format))
        true // For full dates, we assume the year range is valid
    }
  } catch {
    case _: DateTimeParseException => false // If parsing fails, return false
  }
}
