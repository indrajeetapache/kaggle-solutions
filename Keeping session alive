import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._
import org.apache.spark.sql.{DataFrame, SparkSession}

val spark = SparkSession.builder()
  .appName("Dynamic Timestamp Formatting")
  .getOrCreate()

// Function to detect timestamp precision and apply the correct format
def formatTimestampsDynamically(df: DataFrame): DataFrame = {
  // Identify timestamp columns
  val timestampColumns = df.schema.fields.filter(_.dataType == TimestampType).map(_.name)
  
  // Process each timestamp column to detect precision and apply formatting
  val formattedCols = timestampColumns.map { colName =>
    // Sample the first non-null value in the column to determine precision
    val sampleTimestamp = df.select(col(colName)).filter(col(colName).isNotNull).first().getTimestamp(0)
    
    // Determine the precision of the timestamp
    val precision = sampleTimestamp.toString.split("\\.").last.length
    
    // Decide the format based on the precision
    val desiredFormat = precision match {
      case 3 => "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"  // Milliseconds
      case 2 => "yyyy-MM-dd'T'HH:mm:ss.SS'Z'"   // Centiseconds
      case 1 => "yyyy-MM-dd'T'HH:mm:ss.S'Z'"    // Deciseconds
      case _ => "yyyy-MM-dd'T'HH:mm:ss'Z'"      // No fractional seconds
    }
    
    // Apply the format to the column
    date_format(col(colName), desiredFormat).alias(colName)
  }
  
  // Select all columns, replacing the timestamp columns with their formatted versions
  val allColumns = df.columns.map(colName => 
    if (timestampColumns.contains(colName)) col(colName) else df(colName)
  )
  
  // Create the final DataFrame with both formatted and original columns
  df.select(allColumns: _*).select(formattedCols ++ df.columns.diff(timestampColumns).map(col): _*)
}

// Example usage
val jsonDF = spark.read
  .format("json")
  .load("/path/to/your/json")

// Apply dynamic formatting to the DataFrame
val formattedDF = formatTimestampsDynamically(jsonDF)

// Show the results
formattedDF.show()

// Optionally, you can save the formatted data back to JSON or any other format
formattedDF.write
  .format("json")
  .save("/path/to/formatted_output.json")
