# Check the type of each item in 'reconciliation_metrics'
print(df1_exploded['reconciliation_metrics'].apply(type).value_counts())

# Optionally, print out any rows that are not lists to inspect them
for index, item in df1_exploded['reconciliation_metrics'].iteritems():
    if not isinstance(item, list):
        print(f"Index {index}: {item} (Type: {type(item)})")

def extract_audit_run_id(metrics_list):
    if not isinstance(metrics_list, list):
        return None  # Return None or an empty list if the input is not a list
    return [metric.get('audit_run_id', None) for metric in metrics_list if isinstance(metric, dict)]

# Reapply the function with the updated error handling
df1_exploded['audit_run_ids'] = df1_exploded['reconciliation_metrics'].apply(extract_audit_run_id)

def extract_audit_run_id(metrics_list):
    # Debug: Print the input to see what's going wrong
    print(f"Processing: {metrics_list}")
    if not isinstance(metrics_list, list):
        print("Error: Not a list")
        return None
    return [metric.get('audit_run_id', None) for metric in metrics_list if isinstance(metric, dict)]

# Reapply to check the outputs in the console
df1_exploded['audit_run_ids'] = df1_exploded['reconciliation_metrics'].apply(extract_audit_run_id)

======
def extract_audit_run_id(metrics_list):
    # This function extracts 'audit_run_id' from each dict in the list
    # and returns a list of these IDs
    return [metric.get('audit_run_id', None) for metric in metrics_list if isinstance(metric, dict)]

# Apply this function to the DataFrame column
df1_exploded['audit_run_ids'] = df1_exploded['reconciliation_metrics'].apply(extract_audit_run_id)


def extract_tgt_rec_count(metrics_list):
    # Extracts 'tgt_rec_count' from each dict in the list
    return [metric.get('tgt_rec_count', None) for metric in metrics_list if isinstance(metric, dict)]

# Apply this function
df1_exploded['tgt_rec_counts'] = df1_exploded['reconciliation_metrics'].apply(extract_tgt_rec_count)

# Option to explode the list if you need one ID per row (may duplicate other row data)
df1_exploded = df1_exploded.explode('audit_run_ids')
df1_exploded = df1_exploded.explode('tgt_rec_counts')


=========
# Unpack 'other_keys' into separate columns directly within the DataFrame
df = df.join(df['other_keys'].apply(pd.Series))

# Optionally, you can drop the original 'other_keys' column if it's no longer needed
df.drop('other_keys', axis=1, inplace=True)

print(df)

# Further flatten nested dictionaries like 'reconciliation_metrics'
df = df.join(df['reconciliation_metrics'].apply(pd.Series))

# Remove the now redundant 'reconciliation_metrics' column
df.drop('reconciliation_metrics', axis=1, inplace=True)

print(df)

===
import pandas as pd

# Assuming df1 and df2 are your DataFrames and both have a column named 'reconciliation_metrics'

# Exploding the 'reconciliation_metrics' column in both DataFrames
df1_exploded = df1.explode('reconciliation_metrics')
df2_exploded = df2.explode('reconciliation_metrics')

# Extract 'audit_run_id' and 'tgt_rec_count' from the dictionaries in the exploded DataFrames
df1_exploded['audit_run_id'] = df1_exploded['reconciliation_metrics'].apply(lambda x: x.get('audit_run_id'))
df1_exploded['tgt_rec_count'] = df1_exploded['reconciliation_metrics'].apply(lambda x: x.get('tgt_rec_count'))

df2_exploded['audit_run_id'] = df2_exploded['reconciliation_metrics'].apply(lambda x: x.get('audit_run_id'))
df2_exploded['tgt_rec_count'] = df2_exploded['reconciliation_metrics'].apply(lambda x: x.get('tgt_rec_count'))
