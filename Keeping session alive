val combinedDf = flaggedDataFrame
  .withColumn("next_flag", lead("flag", 1).over(windowSpecLead))
  .withColumn("next_line", lead("line", 1).over(windowSpecLead))
  .withColumn("test_combined",
    when($"flag" === 1 && $"next_flag" === 1,
      concat($"line", $"next_line"))
    .otherwise($"line"))
  .withColumn("is_combined",
    when($"flag" === 1 && $"next_flag" === 1 && 
      size(split($"test_combined", "\\" + effectiveReplacementChar)) === schema.fields.length,
      true)
    .otherwise(false))
  .withColumn("prev_combined", lag("is_combined", 1).over(windowSpecLead))
  .withColumn("can_combine",
    when($"flag" === 1 && $"next_flag" === 1 && coalesce($"prev_combined", false) === false,
      size(split($"test_combined", "\\" + effectiveReplacementChar)) === schema.fields.length)
    .otherwise(false))
  .withColumn("combined_line",
    when($"can_combine", $"test_combined")
    .otherwise($"line"))
.withColumn("to_keep", 
    $"flag" === 0 || // Complete records
    ($"flag" === 1 && $"next_flag" === 1 && $"can_combine") || // First part of valid combination
    ($"flag" === 1 && $"next_flag" === 0) || // Last record
    ($"flag" === 1 && !$"can_combine" && !coalesce($"prev_combined", false)) // Invalid/standalone records
  )

=====
.filter(
  $"flag" === 0 || // Complete records
  ($"flag" === 1 && $"can_combine") || // First part of valid combinations
  ($"flag" === 1 && !$"can_combine" && !coalesce($"prev_combined", false)) // Invalid/standalone records
)
=====

val combinedDf = flaggedDataFrame
  // First, add unique ID lead to ensure sequential pairing
  .withColumn("uniqueidlead", lead("unique_id", 1).over(windowSpecLead))
  .withColumn("next_flag", lead("flag", 1).over(windowSpecLead))
  .withColumn("next_line", lead("line", 1).over(windowSpecLead))
  // Add initial is_combined flag
  .withColumn("is_combined", lit(false))
  // Calculate prev_combined to check previous row status
  .withColumn("prev_combined", lag("is_combined", 1).over(windowSpecLead))
  // Test combined only if previous row wasn't combined
  .withColumn("test_combined",
    when($"flag" === 1 && 
         $"next_flag" === 1 && 
         $"uniqueidlead" === ($"unique_id" + 1) &&
         !coalesce($"prev_combined", false),
      concat($"line", $"next_line"))
    .otherwise($"line"))
  // Check if combination is valid
  .withColumn("can_combine",
    when($"flag" === 1 && 
         $"next_flag" === 1 && 
         $"uniqueidlead" === ($"unique_id" + 1) &&
         !coalesce($"prev_combined", false),
      size(split($"test_combined", "\\" + effectiveReplacementChar)) === schema.fields.length)
    .otherwise(false))
  // Update is_combined based on can_combine
  .withColumn("is_combined", $"can_combine")
  // Create final combined line
  .withColumn("combined_line",
    when($"can_combine", $"test_combined")
    .otherwise($"line"))
  // Determine which rows to keep
  .withColumn("to_keep",
    $"flag" === 0 || // Complete records
    ($"flag" === 1 && $"can_combine") || // First part of valid combinations
    ($"flag" === 1 && !$"can_combine" && !coalesce($"prev_combined", false)) // Standalone/invalid records
  )


======
12.12

.withColumn("to_keep",
  $"flag" === 0 || // Complete records
  ($"flag" === 1 && $"can_combine") || // Keep first row of combination
  ($"flag" === 1 && !$"can_combine" && $"next_flag" === 0) || // Last record
  ($"flag" === 1 && !$"can_combine" && !$"is_combined" && !coalesce($"prev_combined", false)) // Standalone records that aren't part of any combination
)

========

val combinedDf = flaggedDataFrame
 .withColumn("uniqueidlead", lead("unique_id", 1).over(windowSpecLead))
 .withColumn("next_flag", lead("flag", 1).over(windowSpecLead))
 .withColumn("next_line", lead("line", 1).over(windowSpecLead))
 .withColumn("is_combined", lit(false))
 .withColumn("prev_combined", lag("is_combined", 1).over(windowSpecLead))
 .withColumn("test_combined",
   when($"flag" === 1 && 
        $"next_flag" === 1 && 
        $"uniqueidlead" === ($"unique_id" + 1) &&
        !coalesce($"prev_combined", false),
     concat($"line", $"next_line"))
   .otherwise($"line"))
 .withColumn("initial_can_combine",
   when($"flag" === 1 && 
        $"next_flag" === 1 && 
        $"uniqueidlead" === ($"unique_id" + 1) &&
        !coalesce($"prev_combined", false),
     size(split($"test_combined", "\\" + effectiveReplacementChar)) === schema.fields.length)
   .otherwise(false))
 .withColumn("can_combine",
   when($"initial_can_combine" && coalesce(lag($"initial_can_combine", 1).over(windowSpecLead), false), 
     false)
   .otherwise($"initial_can_combine"))
 .withColumn("is_combined", $"can_combine")
 .withColumn("combined_line",
   when($"can_combine", $"test_combined")
   .otherwise($"line"))
 .withColumn("to_keep",
   $"flag" === 0 || 
   ($"flag" === 1 && $"can_combine") ||
   ($"flag" === 1 && !$"can_combine" && $"next_flag" === 0) ||
   ($"flag" === 1 && !$"can_combine" && !$"is_combined" && !coalesce($"prev_combined", false)))


==========

// Pass 1 - Initial combination detection
val pass1 = flaggedDataFrame
 // Get next row values for comparison
 .withColumn("uniqueidlead", lead("unique_id", 1).over(windowSpecLead))
 .withColumn("next_flag", lead("flag", 1).over(windowSpecLead)) 
 .withColumn("next_line", lead("line", 1).over(windowSpecLead))
 
 // Initialize combination flags
 .withColumn("is_combined", lit(false))
 .withColumn("prev_combined", lag("is_combined", 1).over(windowSpecLead))
 
 // Test if rows can be combined based on flags and consecutive IDs
 .withColumn("test_combined",
   when($"flag" === 1 && 
        $"next_flag" === 1 && 
        $"uniqueidlead" === ($"unique_id" + 1),
     concat($"line", $"next_line"))
   .otherwise($"line"))
   
 // Check if combined line meets schema requirements
 .withColumn("initial_can_combine",
   when($"flag" === 1 && 
        $"next_flag" === 1 && 
        $"uniqueidlead" === ($"unique_id" + 1),
     size(split($"test_combined", "\\" + effectiveReplacementChar)) === schema.fields.length)
   .otherwise(false))
   
 // Set initial combination status
 .withColumn("is_combined", $"initial_can_combine")

// Pass 2 - Prevent chain combinations and finalize
val combinedDf = pass1
 // Get previous row combination info
 .withColumn("prev_is_combined", lag($"is_combined", 1).over(windowSpecLead))
 .withColumn("prev_uniqueidlead", lag($"uniqueidlead", 1).over(windowSpecLead))
 
 // Check if row was used in previous combination
 .withColumn("consumed_by_prev",
   ($"prev_is_combined" === true) && ($"prev_uniqueidlead" === $"unique_id"))
   
 // Only allow combination if row wasn't used before
 .withColumn("can_combine",
   when($"initial_can_combine" && !$"consumed_by_prev", true)
   .otherwise(false))
   
 // Create final combined lines
 .withColumn("combined_line",
   when($"can_combine", $"test_combined")
   .otherwise($"line"))
   
 // Keep complete records, first rows of combinations, and standalone records
 .withColumn("to_keep",
   $"flag" === 0 || // Complete records 
   ($"flag" === 1 && $"can_combine") || // First rows of combinations
   ($"flag" === 1 && !$"can_combine" && !$"consumed_by_prev")) // Standalone records
