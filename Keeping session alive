import org.apache.spark.sql.{DataFrame, SparkSession}
import org.apache.spark.sql.functions._
import org.apache.spark.sql.expressions.Window

val spark = SparkSession.builder()
  .appName("example")
  .master("local[*]")  // Adjust based on your setup
  .getOrCreate()

import spark.implicits._

// Sample DataFrame
val df = Seq(
  ("A"),
  ("A"),
  ("B"),
  ("B"),
  ("B"),
  ("C"),
  ("C"),
  ("D"),
  ("D")
).toDF("key")

// Function to perform recursive aggregation
def recursiveAggregation(df: DataFrame, callCount: Int = 1): DataFrame = {
  // Log the call count
  println(s"Recursive call count: $callCount")

  // Define a window specification with an orderBy clause on the key column
  val windowSpec = Window.orderBy("key")

  // Generate a row number for each row
  val dfWithId = df.withColumn("value", row_number().over(windowSpec))

  // Get the maximum value in the value column, which indicates the total count
  val maxId = dfWithId.agg(max("value")).head.getLong(0)

  // If maxId is 1, it means there's only one row, so return the DataFrame
  if (maxId == 1) {
    return dfWithId
  }

  // Calculate the range dynamically
  val range = maxId match {
    case count if count < 50 => 2
    case count => (count / 10).toInt
  }

  // Assign a constant partition_id if maxId is less than 50, otherwise calculate partition_id based on the range
  val dfWithPartitionId = if (maxId < 50) {
    dfWithId.withColumn("partition_id", lit(0))
  } else {
    dfWithId.withColumn("partition_id", floor(col("value") / range))
// val randomExpression = expr(s"floor($n + (rand() * (${range} - $n)))")  // generates a random number between n and range
  dfWithId.withColumn("partition_id", randomExpression)
  }

  // Group by the partition ID and key, then aggregate
  val aggregatedDF = dfWithPartitionId.groupBy("partition_id", "key")
    .agg(md5(concat_ws("", collect_list(dfWithPartitionId("value").cast("string")))).alias("hash"))

  // Call the function recursively with the new DataFrame, incrementing the call count
  recursiveAggregation(aggregatedDF.drop("partition_id", "value"), callCount + 1)
}

// Call the recursive aggregation function
val resultDF = recursiveAggregation(df)
resultDF.show()


val resultDF = df.withColumn("substring", substring(col("yourColumn"), 1, 5))



=======


val resultDf = rowCount match {
      case count if count > 10 =>
        // Perform operations for count > 10
        df.filter(df("some_column") > some_value)
      
      case count if count > 5 && count <= 10 =>
        // Perform operations for 5 < count <= 10
        df.withColumn("new_column", df("some_column") * some_value)
      
      case _ =>
        // Optionally handle other cases
        df
    }


Responsive Technical Support: On numerous occasions, I have extended my support to the team on an on-demand basis, especially during critical technical challenges. My expertise and timely intervention have often been crucial in navigating through complex technical roadblocks, ensuring that our projects stay on track and meet the stipulated deadlines.
Technical Mentoring: I took the initiative to groom my direct reports technically, ensuring they are well-equipped to complete their tasks efficiently and resolve issues in a timely manner. Through regular one-on-one mentoring sessions and group discussions, I have seen a noticeable improvement in their problem-solving skills and technical proficiency, which in turn, has positively impacted our team's overall productivity and project delivery timelines.
Client Engagement for Framework Demonstrations: Understanding the importance of transparent communication and client engagement, I scheduled and led multiple calls with all our clients to demonstrate the framework we are employing. These interactions have not only instilled confidence in our clients regarding our technical capabilities but have also provided an avenue for receiving valuable feedback, enabling us to fine-tune our framework to better meet their needs.

Risk control performance
=======================
Risk Identification and Mitigation: I identified a significant risk pertaining to the lack of proper documentation and adherence to a consistent coding style, recognizing that these aspects are pivotal for the maintainability and scalability of our framework. Subsequently, I initiated measures to standardize documentation and coding practices, thereby significantly mitigating the associated risks.
Knowledge Sharing and Documentation: In order to eradicate the siloing of crucial information, I advocated for a comprehensive documentation strategy where all pertinent information is meticulously documented and illustrated with examples. This practice has encouraged a shared understanding and facilitated a smoother collaboration among team members, thereby enhancing our collective ability to address technical challenges.
Vigilant Code Review and Individual Contribution: From a coding standpoint, I have been contributing as an individual while also reviewing the code of my teammates in a more vigilant manner. This dual role has enabled me to ensure that temporary fixes, hard coding, or the addition of unnecessary keys in the config files are avoided. This vigilance has significantly contributed to the code quality and, by extension, the overall reliability and efficiency of our projects.
Alignment with Citi's Consent Order Work: Ensuring our frameworks are in alignment with Citi's consent order work has been a priority. Through diligent review and continuous communication with the relevant stakeholders, I have ensured that our frameworks are compliant and in sync with the stipulated guidelines, thus safeguarding the organization from potential legal and operational repercussions.

financial performance
=====================

ramework Adoption and Resource Optimization: Our framework's widespread acceptance among other teams is a clear indicator of its value. Its adoption has negated the necessity for individual code development, substantially reducing the resources required by application teams. This not only signifies a reduction in development time but also translates to cost savings, as fewer resources are needed to achieve the desired outcomes.
Enhanced Response Time and Faster Deliveries: With the adoption of our framework, application teams have witnessed a notable improvement in response times and project delivery rates. The frameworkâ€™s ability to streamline processes and eliminate redundant tasks has empowered the teams to respond to requirements swiftly and deliver solutions in a faster and more efficient manner, which in turn, could lead to enhanced client satisfaction and potential financial gains.

Future Validation Frameworks for Testing Teams: Looking ahead, we are in the process of creating validation frameworks that aim at bolstering the efficiency and speed at which testing teams can perform validations. This initiative is poised to further reduce the time-to-market and ensure higher quality deliverables, which are critical factors in maintaining a competitive edge and achieving financial prudence.
franchise
========
Timely Responsiveness to Client Requirements: Our routine interactions with the application teams have enabled us to swiftly respond to their requirements. By providing timely assistance and technical support, we have facilitated a smoother adoption process of our frameworks, thereby addressing their needs in a prompt and efficient manner.
Solving Standard File Loads: Although lacking precise data, our estimations suggest that our frameworks are now capable of resolving a substantial portion, approximately 40-50%, of standard file loads. This represents a significant alleviation of the operational burden on the application teams, allowing them to redirect their focus and resources towards other critical areas.
Ease of Framework Adoption and Continuous Improvement: The design of our frameworks emphasizes ease of adoption. We have been tirelessly working on refining our frameworks based on the feedback received, and concurrently, enhancing the accompanying documentation with sample config files to further simplify the adoption process. This iterative improvement not only augments the utility of our frameworks but also exemplifies our commitment to client satisfaction.
Simplified Adoption and Validation Process: The continuous refinement of our frameworks has culminated in a more streamlined adoption and validation process. The ease with which application teams can now adopt and validate our frameworks is a testament to our dedication to reducing operational friction and accelerating the delivery timelines.
