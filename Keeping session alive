import java.time.format.{DateTimeFormatter, DateTimeParseException}
import java.time.{Year, YearMonth}

def isValidDate(value: String, format: String): Boolean = {
  try {
    val currentYear = Year.now().getValue // Get the current year
    val formatter = DateTimeFormatter.ofPattern(format)

    if (format.contains("yyyy") && format.length <= 7) { // Checks for "yyyy" and length to differentiate from full date formats
      val yearMonth = YearMonth.parse(value, formatter)
      yearMonth.getYear >= 1900 && yearMonth.getYear <= currentYear
    } else if (format == "yyyy") {
      val year = Year.parse(value, formatter)
      year.getValue >= 1900 && year.getValue <= currentYear
    } else {
      // This will handle full dates, but won't be reached for year-month combinations due to the first condition
      YearMonth.parse(value, formatter) // Just try to parse, it will throw an exception if it doesn't match
      true
    }
  } catch {
    case _: DateTimeParseException => false // If parsing fails, return false
  }
}
